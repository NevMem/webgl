html
	head
		meta(sharset = 'utf-8')
		style.
			* {
				padding: 0 0;
				margin: 0 0;
			}

			.menu {
				position: fixed;
				left: 0px;
				bottom: 0px;
				padding: 10px 10px;
				color: white;
			}

	body
		canvas#frame
		div.menu

		script(src="https://code.jquery.com/jquery-3.3.1.min.js")
		script(src = '/gl-matrix.js')
		script(src = '/scripts.js')

		script.
			var frame, gl, shaderProgram, postProcessingShaderProgram, quadVBO
			var frameBuffer1, bufferTexture1, 
				frameBuffer2, bufferTexture2
			var depthBuffer
			var model
			var startTimePoint = Date.now()
			var eyeMatrix = new Float32Array(16), 
				worldMatrix = new Float32Array(16), 
				projectionMatrix = new Float32Array(16)
			//var mainVBO, mainIBO, mainVAO
			var camera

			var mainModel

			function renderWorld(){
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1)
				
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
				gl.enable(gl.DEPTH_TEST)
				gl.depthFunc(gl.LESS)

				shaderProgram.start()

				mat4.perspective(projectionMatrix, 45 * Math.PI / 180.0, frame.width / frame.height, 0.1, 1000.0)
				mat4.identity(worldMatrix)

				shaderProgram.setUniform('eyeMatrix', camera.getEyeMatrix(), 'mat4')
				shaderProgram.setUniform('worldMatrix', worldMatrix, 'mat4')
				shaderProgram.setUniform('projectionMatrix', projectionMatrix, 'mat4')


				shaderProgram.setUniform('paintColor', [ .5, .5, .5 ], 'v3')
				shaderProgram.setUniform('size', 1, 'f')
				shaderProgram.setUniform('lightPosition', camera.getPosition(), 'v3')

				mainModel.render()

				shaderProgram.stop()
			}

			function postProcessing(){
				/* POST PROCESSING FIRST STAGE */
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2)
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
				gl.activeTexture(gl.TEXTURE0)
				gl.bindTexture(gl.TEXTURE_2D, bufferTexture1)
				postProcessingShaderProgram.start()
				postProcessingShaderProgram.setUniform('uResolution', [ frame.width, frame.height ], 'v2')
				postProcessingShaderProgram.setUniform('tx1', 0, 'i')
				postProcessingShaderProgram.setUniform('dir', [ 0, 0 ], 'v2')
				quadVBO.bind()
				loc = postProcessingShaderProgram.getAttributeLocation('position')
				gl.enableVertexAttribArray(loc)
				gl.vertexAttribPointer(loc, 2, gl.FLOAT, gl.FALSE, 2 * Float32Array.BYTES_PER_ELEMENT, 0)
				gl.drawArrays(gl.TRIANGLES, 0, 6)
				quadVBO.unbind()
				postProcessingShaderProgram.stop()


				/* POST PROCESSING SECOND STAGE */
				gl.bindFramebuffer(gl.FRAMEBUFFER, null)
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
				gl.activeTexture(gl.TEXTURE0)
				gl.bindTexture(gl.TEXTURE_2D, bufferTexture2)
				postProcessingShaderProgram.start()
				postProcessingShaderProgram.setUniform('uResolution', [ frame.width, frame.height ], 'v2')
				postProcessingShaderProgram.setUniform('tx1', 0, 'i')
				postProcessingShaderProgram.setUniform('dir', [ 0, 0 ], 'v2')
				quadVBO.bind()
				gl.drawArrays(gl.TRIANGLES, 0, 6)
				quadVBO.unbind()
				postProcessingShaderProgram.stop()
			}

			var tick = 0
			function loop(){
				++tick

				renderWorld()				

				postProcessing()				

				/* NEXT FRAME REQUEST */
				requestAnimationFrame(loop)
			}

			async function initGL(){
				gl = frame.getContext('webgl2')	
					
				var vShaderText, fShaderText, ftShaderText, vtShaderText

				await loadResource('vertexBasic.glsl').then(function(data){
					vShaderText = data
					return loadResource('fragmentBasic.glsl')
				}).then(function(data){
					fShaderText = data
					return loadResource('fragmentTexture.glsl')
				}).then(function(data){
					ftShaderText = data
					return loadResource('vertexTexture.glsl')
				}).then(function(data){
					vtShaderText = data
				})

				shaderProgram = createShaderProgram(vShaderText, fShaderText)
				shaderProgram.initUniforms([ 'uResolution', 'uTime', 'projectionMatrix', 'eyeMatrix', 'worldMatrix', 'lightPosition', 'paintColor', 'size' ])

				postProcessingShaderProgram = createShaderProgram(vtShaderText, ftShaderText)
				postProcessingShaderProgram.initUniforms([ 'uResolution', 'tx1', 'dir' ])

				gl.clearColor(.1, .1, .1, 1.0)

				quadVBO = createVBO()
				quadVBO.setData([ -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ])
			
				model = await loadModel('sphere.ply')
			
				var DATA = createDataWithNormals(model.vertices, model.indecies)

				mainModel = createModel(DATA)

				bufferTexture1 = createTexture(frame.width, frame.height)
				frameBuffer1 = createFramebuffer(bufferTexture1)

				bufferTexture2 = createTexture(frame.width, frame.height)
				frameBuffer2 = createFramebuffer(bufferTexture2)
				
				depthBuffer = createRenderBuffer(frame.width, frame.height, frameBuffer1)

				loop()
			}

			$(document).ready(function(){
				frame = $('#frame')[0]

				frame.width = window.innerWidth
				frame.height = window.innerHeight

				camera = createCamera()

				$(window).on('keydown', function(ev){
					if(ev.keyCode == 87){
						camera.moveForward(1)
					} else if(ev.keyCode == 83){
						camera.moveForward(-1)
					} else if(ev.keyCode == 68) {
						camera.rotateHorizontal(-Math.PI / 24.0)
					} else if(ev.keyCode == 65){
						camera.rotateHorizontal(Math.PI / 24.0)
					} else if(ev.keyCode == 38) {
						camera.rotateVertical(Math.PI / 24.0)
					} else if(ev.keyCode == 40) {
						camera.rotateVertical(-Math.PI / 24.0)
					}
				})

				initGL()
			})