html
	head
		meta(sharset = 'utf-8')
		style.
			* {
				padding: 0 0;
				margin: 0 0;
			}

			.menu {
				position: fixed;
				left: 0px;
				bottom: 0px;
				padding: 10px 10px;
				color: white;
			}

	body
		canvas#frame
		div.menu

		script(src="https://code.jquery.com/jquery-3.3.1.min.js")
		script(src = '/gl-matrix.js')
		script(src = '/scripts.js')

		script.
			var frame, gl, shaderProgram, postProcessingShaderProgram, quadVBO
			var frameBuffer1, bufferTexture1, 
				frameBuffer2, bufferTexture2
			var depthBuffer
			var model
			var startTimePoint = Date.now()
			var eyeMatrix = new Float32Array(16), 
				worldMatrix = new Float32Array(16), 
				projectionMatrix = new Float32Array(16)
			var mainVBO, mainIBO
			var camera

			function createPlanet(position, gravity, speed, size, color){
				if(!speed)
					speed = [ 0., 0., 0. ]
				if(!size)
					size = 1.
				if(!color)
					color = [ 1., 1., 1. ]
				return { position: position, size: size, color: color, gravity: gravity, speed: speed }
			}

			var gameModel = [
				createPlanet([ 0, 0, 0 ], 5, [ 0., 0., 0. ], .3, [ 1, 0, 0 ]), 
				createPlanet([ 5, 0, 0 ], 5, [ 0., 5., 0. ], .3, [ 0, 1, 0 ]), 
				//createPlanet([ 0, 10, 0 ], 100, [ 0., 0., 1. ], 1, [ 0, 0, 1 ])
			]

			var storedPositions = [], stpos = 0

			for(var i = 0;i < 50;i++){
				storedPositions[i] = [ 0, 0, 0 ]
				storedPositions[i][0] = gameModel[1].position[0] - gameModel[0].position[0]
				storedPositions[i][1] = gameModel[1].position[1] - gameModel[0].position[1]
				storedPositions[i][2] = gameModel[1].position[2] - gameModel[0].position[2]
			}

			var step = .01

			function renderWorld(){
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1)
				
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
				gl.enable(gl.DEPTH_TEST)
				gl.depthFunc(gl.LESS)

				shaderProgram.start()
				mainVBO.bind()
				mainIBO.bind()

				var positionAttr = shaderProgram.getAttributeLocation('position'),
					normalAttr = shaderProgram.getAttributeLocation('normal')
				gl.vertexAttribPointer(positionAttr, 3, gl.FLOAT, gl.FALSE, 6 * Float32Array.BYTES_PER_ELEMENT, 0)
				gl.enableVertexAttribArray(positionAttr)
				gl.vertexAttribPointer(normalAttr, 3, gl.FLOAT, gl.FALSE, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT)
				gl.enableVertexAttribArray(normalAttr)

				mat4.perspective(projectionMatrix, 45 * Math.PI / 180.0, frame.width / frame.height, 0.1, 1000.0)

				mat4.identity(worldMatrix)

				camera.setFollowPoint(gameModel[0].position)
				
				shaderProgram.setUniform('eyeMatrix', camera.getEyeMatrix(), 'mat4')
				shaderProgram.setUniform('worldMatrix', worldMatrix, 'mat4')
				shaderProgram.setUniform('projectionMatrix', projectionMatrix, 'mat4')
				shaderProgram.setUniform('lightPosition', camera.getPosition(), 'v3')

				for(var i = 0;i < gameModel.length;i++){
					var tr = [
						gameModel[i].position[0], 
						gameModel[i].position[1], 
						gameModel[i].position[2], 
					]
					mat4.translate(worldMatrix, worldMatrix, tr)

					shaderProgram.setUniform('size', gameModel[i].size, 'f')
					shaderProgram.setUniform('worldMatrix', worldMatrix, 'mat4')
					shaderProgram.setUniform('paintColor', gameModel[i].color, 'v3')

					gl.drawElements(gl.TRIANGLES, model.indecies.length * 3, gl.UNSIGNED_SHORT, 0)

					mat4.translate(worldMatrix, worldMatrix, [ -tr[0], -tr[1], -tr[2] ])
				}

				for(var i = 0;i < storedPositions.length;i++){
					var tr = [
						storedPositions[i][0] + gameModel[0].position[0], 
						storedPositions[i][1] + gameModel[0].position[1], 
						storedPositions[i][2] + gameModel[0].position[2], 
					]
					mat4.translate(worldMatrix, worldMatrix, tr)

					shaderProgram.setUniform('paintColor', [ .1, .1, .5 ], 'v3')
					shaderProgram.setUniform('size', .2, 'f')
					shaderProgram.setUniform('worldMatrix', worldMatrix, 'mat4')

					gl.drawElements(gl.TRIANGLES, model.indecies.length * 3, gl.UNSIGNED_SHORT, 0)

					mat4.translate(worldMatrix, worldMatrix, [ -tr[0], -tr[1], -tr[2] ])
				}

				//gl.drawElements(gl.TRIANGLES, model.indecies.length * 3, gl.UNSIGNED_SHORT, 0)

				mainVBO.unbind()
				mainIBO.unbind()
				shaderProgram.stop()
			}

			function postProcessing(){
				/* POST PROCESSING FIRST STAGE */
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2)
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
				gl.activeTexture(gl.TEXTURE0)
				gl.bindTexture(gl.TEXTURE_2D, bufferTexture1)
				postProcessingShaderProgram.start()
				postProcessingShaderProgram.setUniform('uResolution', [ frame.width, frame.height ], 'v2')
				postProcessingShaderProgram.setUniform('tx1', 0, 'i')
				postProcessingShaderProgram.setUniform('dir', [ 0, 0 ], 'v2')
				quadVBO.bind()
				loc = postProcessingShaderProgram.getAttributeLocation('position')
				gl.vertexAttribPointer(loc, 2, gl.FLOAT, gl.FALSE, 2 * Float32Array.BYTES_PER_ELEMENT, 0)
				gl.drawArrays(gl.TRIANGLES, 0, 6)
				quadVBO.unbind()
				postProcessingShaderProgram.stop()


				/* POST PROCESSING SECOND STAGE */
				gl.bindFramebuffer(gl.FRAMEBUFFER, null)
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
				gl.activeTexture(gl.TEXTURE0)
				gl.bindTexture(gl.TEXTURE_2D, bufferTexture2)
				postProcessingShaderProgram.start()
				postProcessingShaderProgram.setUniform('uResolution', [ frame.width, frame.height ], 'v2')
				postProcessingShaderProgram.setUniform('tx1', 0, 'i')
				postProcessingShaderProgram.setUniform('dir', [ 0, 0 ], 'v2')
				quadVBO.bind()
				gl.drawArrays(gl.TRIANGLES, 0, 6)
				quadVBO.unbind()
				postProcessingShaderProgram.stop()
			}

			var tick = 0

			function loop(){
				++tick

				for(var i = 0;i < gameModel.length;i++){
					var acceleration = [ 0, 0, 0 ]
					for(var j = 0;j < gameModel.length;j++){
						if(i == j)
							continue
						var r = vec3.distance(gameModel[i].position, gameModel[j].position)
						var force = gameModel[i].gravity * gameModel[j].gravity / r * r
						var vc = getVector(gameModel[i].position, gameModel[j].position)
						vec3.normalize(vc, vc)
						vc[0] *= force / gameModel[i].gravity
						vc[1] *= force / gameModel[i].gravity
						vc[2] *= force / gameModel[i].gravity
						vec3.add(acceleration, acceleration, vc)
					}
					acceleration[0] *= .001
					acceleration[1] *= .001
					acceleration[2] *= .001
					vec3.add(gameModel[i].speed, gameModel[i].speed, acceleration)
				}

				for(var i = 0;i < gameModel.length;i++){
					gameModel[i].position[0] += gameModel[i].speed[0] * step
					gameModel[i].position[1] += gameModel[i].speed[1] * step
					gameModel[i].position[2] += gameModel[i].speed[2] * step
				}

				if(tick % 100 == 0){
					for(var i = 0;i < 3;i++)
						storedPositions[stpos][i] = gameModel[1].position[i] - gameModel[0].position[i]
					stpos++
					if(stpos >= storedPositions.length)
						stpos = 0
				}

				renderWorld()				

				postProcessing()				

				/* NEXT FRAME REQUEST */
				requestAnimationFrame(loop)
			}

			async function initGL(){
				gl = frame.getContext('webgl2')	
					
				var vShaderText, fShaderText, ftShaderText, vtShaderText

				await loadResource('vertexBasic.glsl').then(function(data){
					vShaderText = data
					return loadResource('fragmentBasic.glsl')
				}).then(function(data){
					fShaderText = data
					return loadResource('fragmentTexture.glsl')
				}).then(function(data){
					ftShaderText = data
					return loadResource('vertexTexture.glsl')
				}).then(function(data){
					vtShaderText = data
				})

				shaderProgram = createShaderProgram(vShaderText, fShaderText)
				shaderProgram.initUniforms([ 'uResolution', 'uTime', 'projectionMatrix', 'eyeMatrix', 'worldMatrix', 'lightPosition', 'paintColor', 'size' ])

				postProcessingShaderProgram = createShaderProgram(vtShaderText, ftShaderText)
				postProcessingShaderProgram.initUniforms([ 'uResolution', 'tx1', 'dir' ])

				gl.clearColor(.0, .0, .0, 1.0)
				//gl.enable(gl.DEPTH_TEST)

				quadVBO = createVBO()
				quadVBO.setData([ -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ])
			
				model = await loadModel('sphere.ply')
				
				mainVBO = createVBO()	
				mainIBO = createIBO()

				var DATA = createDataWithNormals(model.vertices, model.indecies)

				mainVBO.setData(DATA.vertices)
				mainIBO.setData(DATA.indecies)

				bufferTexture1 = createTexture(frame.width, frame.height)
				frameBuffer1 = createFramebuffer(bufferTexture1)

				bufferTexture2 = createTexture(frame.width, frame.height)
				frameBuffer2 = createFramebuffer(bufferTexture2)
				
				depthBuffer = createRenderBuffer(frame.width, frame.height, frameBuffer1)

				loop()
			}

			$(document).ready(function(){
				frame = $('#frame')[0]

				frame.width = window.innerWidth
				frame.height = window.innerHeight

				camera = createFollowCamera()

				$(window).on('keydown', function(ev){
					if(ev.keyCode == 87){
						camera.moveForward(1)
					} else if(ev.keyCode == 83){
						camera.moveForward(-1)
					} else if(ev.keyCode == 68) {
						camera.rotateHorizontal(-Math.PI / 24.0)
					} else if(ev.keyCode == 65){
						camera.rotateHorizontal(Math.PI / 24.0)
					} else if(ev.keyCode == 38) {
						camera.rotateVertical(Math.PI / 24.0)
					} else if(ev.keyCode == 40) {
						camera.rotateVertical(-Math.PI / 24.0)
					}
				})

				setInterval(function(){
					var text = 'position: [ ' + formatFloat(camera.getPosition()[0]) + ' ' + formatFloat(camera.getPosition()[1]) + ' ' + formatFloat(camera.getPosition()[2]) + ' ]<br>' + 
						'up: [ ' + formatFloat(camera.up[0]) + ' ' + formatFloat(camera.up[1]) + ' ' + formatFloat(camera.up[2]) + ' ]<br>' 

					for(var i = 0;i < gameModel.length;i++){
						text += 'object ' + i + ': [' + formatFloat(gameModel[i].position[0]) + ' ' + formatFloat(gameModel[i].position[1]) + ' ' + formatFloat(gameModel[i].position[1]) + ']<br>'
					}

					for(var i = 0;i < storedPositions.length;i++){
						text += 'stpos ' + i + ': [ ' + formatFloat(storedPositions[i][0]) + ' ' + formatFloat(storedPositions[i][1]) + ' ' + formatFloat(storedPositions[i][2]) + ' ]<br>'
					}

					text += 'tick: ' + tick + '<br>'
					//$('.menu').html(text)
				}, 500)

				initGL()
			})